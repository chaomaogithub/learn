为什么三次握手
为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。


这就很明白了，防止了服务器端的一直等待而浪费资源。

但是三次握手的过程不是完美无缺，也有一个问题，就是SYN Flood攻击，主要攻击手段是向服务端发送大量SYN请求连接，服务端响应SYN请求向客户端发送SYN+ACK，但是，此时客户端却不再向服务端发送最后的ACK，导致占用了服务端大量的资源。这里不再细述。



标志位               作用
SYN                 表示请求建立连接
FIN                 表示请求断开连接
Seq                 表示曾经发送过数据的字节数+1，0表示之前没有发送过数据
Len                 本次收到的数据字节大小，0表示本次没有收到数据
ACK                 表示对对方过来的请求的确认
Ack                 表示下次对方发送过来的Seq指令的值


四次挥手

为什么TIME_WAIT状态要等待2MSL？ 客户端接收到服务器端的 FIN报文后进入此状态，此时并不是直接进入 CLOSED状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

其一，确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
其二，等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

参考文章：
https://juejin.im/post/5d1dcf646fb9a07ec27bc1b7
https://juejin.im/post/5cdbdd3bf265da03b57b7cf1


